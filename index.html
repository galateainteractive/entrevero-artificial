<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Entrevero - Player Estável</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #00ff41; 
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            user-select: none;
        }

        h1 { margin-bottom: 10px; letter-spacing: 2px; }

        .controls {
            border: 1px solid #333;
            padding: 30px;
            background: #222;
            border-radius: 8px;
            text-align: center;
            width: 320px;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.2);
        }

        button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 20px 40px;
            font-size: 20px;
            font-weight: 900;
            cursor: pointer;
            margin-bottom: 20px;
            text-transform: uppercase;
            width: 100%;
            transition: all 0.2s;
        }

        button:hover { background: #fff; transform: scale(1.02); }
        button:active { transform: scale(0.98); }
        button:disabled { background: #555; color: #888; cursor: wait; }

        button.stop-mode {
            background: #ff0055;
            color: #fff;
            box-shadow: 0 0 10px #ff0055;
        }

        #status { margin-bottom: 15px; font-weight: bold; letter-spacing: 1px; min-height: 20px; }

        #log {
            font-size: 12px;
            color: #666;
            height: 150px;
            overflow-y: hidden;
            border-top: 1px solid #444;
            padding-top: 10px;
            text-align: center; 
            display: flex;
            flex-direction: column-reverse; 
        }
    </style>
</head>
<body>

    <h1>ENTREVERO_AI</h1>

    <div class="controls">
        <button id="btnControl" onclick="togglePlay()">INICIAR SISTEMA</button>
        
        <div id="status">SISTEMA ONLINE</div>
        <div id="log"></div>
    </div>

    <script>
    // --- CONFIGURAÇÃO ---
    const songStructure = [
        { name: "A_01", variations: 19 }, 
    ];

    // --- VARIÁVEIS DO SISTEMA ---
    let audioCtx;
    let audioBuffers = {}; // Cache
    let isPlaying = false;
    let nextNoteTime = 0;
    let currentSourceNode = null;
    let shuffleBags = {}; 
    let retryTimer;
    
    // O "Freio de Mão" para downloads
    let downloadController = null; 

    // 1. CONTROLE PRINCIPAL
    function togglePlay() {
        // Inicializa AudioContext no primeiro clique (regra dos navegadores)
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        if (isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    }

    // 2. LÓGICA DE STREAMING
    async function startPlayback() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        isPlaying = true;
        nextNoteTime = audioCtx.currentTime + 0.1; 
        
        // Reinicia o controlador de downloads
        downloadController = new AbortController();

        // UI Update
        const btn = document.getElementById('btnControl');
        btn.innerText = "PARAR";
        btn.classList.add("stop-mode");
        btn.disabled = false;
        
        document.getElementById('status').innerText = "INICIANDO BUFFER...";
        document.getElementById('log').innerHTML = ""; 

        // Começa o ciclo
        processNextChunk();
    }

    function stopPlayback() {
        isPlaying = false;
        
        // 1. Cancela qualquer agendamento de retry
        clearTimeout(retryTimer); 
        
        // 2. FREIO DE MÃO: Cancela qualquer download pendente AGORA
        if (downloadController) {
            downloadController.abort();
            downloadController = null;
        }

        // 3. Para o som atual imediatamente
        if (currentSourceNode) {
            try { currentSourceNode.stop(); } catch(e){}
            currentSourceNode = null;
        }

        // 4. Reset UI
        const btn = document.getElementById('btnControl');
        btn.innerText = "REINICIAR";
        btn.classList.remove("stop-mode");
        btn.disabled = false;
        document.getElementById('status').innerText = "SINAL INTERROMPIDO.";
    }

    // LÓGICA RECURSIVA BLINDADA
    async function processNextChunk() {
        if (!isPlaying) return;

        const nextFile = getNextRandomFile();
        
        try {
            // Se já está no cache, avisa visualmente mas é rápido
            if (audioBuffers[nextFile]) {
                // document.getElementById('status').innerText = "CACHE OK";
            } else {
                document.getElementById('status').innerText = "BAIXANDO PACOTE...";
            }

            // AQUI ESTÁ A PROTEÇÃO: Passamos o 'signal' para poder cancelar
            await loadFile(nextFile, downloadController.signal);
            
            // Checagem Dupla: Se o usuário clicou STOP enquanto baixava
            if (!isPlaying) return; 

            playAndScheduleNext(nextFile);

        } catch (e) {
            // Se o erro foi "AbortError", é porque o usuário clicou STOP. Ignora.
            if (e.name === 'AbortError') {
                console.log("Download cancelado pelo usuário.");
                return;
            }

            console.error("Erro de rede:", e);
            if (isPlaying) {
                document.getElementById('status').innerText = "ERRO REDE. TENTANDO...";
                retryTimer = setTimeout(processNextChunk, 1000); 
            }
        }
    }

    function playAndScheduleNext(filename) {
        if (!isPlaying) return;

        const buffer = audioBuffers[filename];
        const duration = buffer.duration;
        
        // Sincronia Adaptativa
        let playTime = nextNoteTime;
        if (playTime < audioCtx.currentTime) {
            playTime = audioCtx.currentTime; // Toca agora se estiver atrasado
        }

        playBuffer(filename, playTime);
        
        // Atualiza UI
        let isAI = filename.includes("VAR");
        updateLog(isAI);
        document.getElementById('status').innerText = "TRANSMITINDO";

        // Prepara tempo da próxima
        nextNoteTime = playTime + duration;

        // Chama a próxima recursivamente
        processNextChunk(); 
    }

    // --- FERRAMENTAS ---

    async function loadFile(filename, abortSignal) {
        if (audioBuffers[filename]) return; 

        // O fetch agora aceita o sinal de abortar
        const response = await fetch(filename, { signal: abortSignal });
        
        if (!response.ok) throw new Error(`404: ${filename}`);
        
        const arrayBuffer = await response.arrayBuffer();
        
        // Decodificação (Atenção: decodeAudioData não aceita abort signal em todos browsers, 
        // mas se pararmos a lógica principal, o resultado é descartado)
        if (!isPlaying) return; 
        audioBuffers[filename] = await audioCtx.decodeAudioData(arrayBuffer);
    }

    function playBuffer(key, time) {
        // Última verificação de segurança
        if (!isPlaying || !audioBuffers[key]) return;

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffers[key];
        source.connect(audioCtx.destination);
        source.start(time);
        currentSourceNode = source; 
        
        // Limpa a referência quando acabar (opcional, para limpeza)
        source.onended = () => {
            if (currentSourceNode === source) currentSourceNode = null;
        };
    }

    function getNextRandomFile() {
        const blockConfig = songStructure[0]; 
        
        let bag = shuffleBags[blockConfig.name];
        if (!bag || bag.length === 0) {
            bag = [];
            let totalOptions = 1 + blockConfig.variations;
            for (let i = 0; i < totalOptions; i++) bag.push(i);
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
            shuffleBags[blockConfig.name] = bag;
        }

        let choice = bag.pop();
        if (choice === 0) return `${blockConfig.name}_ORG.mp3`;
        return `${blockConfig.name}_VAR_${choice}.mp3`;
    }

    function updateLog(isAI) {
        const log = document.getElementById('log');
        const color = isAI ? "#ff0055" : "#00ff41"; 
        let wave = "";
        let len = Math.floor(Math.random() * 10) + 5;
        for(let i=0; i<len; i++) wave += "|";
        log.innerHTML = `<div style="color:${color}; letter-spacing:3px; opacity:0.7;">${wave}</div>` + log.innerHTML;
    }

    </script>
</body>
</html>
